---
layout: framework
sidebar: tag-list
---

{%- if site.posts.size > 0 -%}

  {%- include functions.html func='log' level='debug' msg='Get tags value' -%}
  {%- include functions.html func='get_tags' -%}
  {% assign tags = return %}

  <!-- Tag Graph Visualization -->
  <div class="tag-graph-container">
    <svg id="tag-graph"></svg>
    <div id="tag-tooltip" class="tag-tooltip"></div>
  </div>

  <!-- Post-Tag Data for JavaScript -->
  <script id="post-tags-data" type="application/json">
  [
    {% for post in site.posts %}
      {
        "title": {{ post.title | jsonify }},
        "tags": {{ post.tags | jsonify }}
      }{% unless forloop.last %},{% endunless %}
    {% endfor %}
  ]
  </script>

  <!-- Tag List -->
  {% assign keys = tags %}
  {% assign field = 'tags' %}
  {%- include views/segments.html -%}

{%- endif -%}

<style>
  /* Tag Graph Container */
  .tag-graph-container {
    margin: 40px 0 60px;
    position: relative;
    background: linear-gradient(135deg, #f5f7fa 0%, #e8eef5 100%);
    border-radius: 16px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
    overflow: hidden;
  }

  #tag-graph {
    width: 100%;
    height: 450px;
    display: block;
  }

  /* Graph Links */
  .graph-link {
    stroke: #1e88e5;
    stroke-opacity: 0.4;
    fill: none;
    transition: stroke-opacity 0.3s ease;
  }

  .graph-link.highlighted {
    stroke-opacity: 0.9;
  }

  .graph-link.dimmed {
    stroke-opacity: 0.1;
  }

  /* Graph Nodes */
  .graph-node {
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .graph-node circle {
    fill: #1e88e5;
    stroke: #fff;
    stroke-width: 2px;
    transition: all 0.3s ease;
  }

  .graph-node:hover circle {
    fill: #1565c0;
    stroke-width: 3px;
    filter: drop-shadow(0 0 8px rgba(30, 136, 229, 0.6));
  }

  .graph-node.dimmed circle {
    fill: #b0bec5;
    opacity: 0.4;
  }

  .graph-node.highlighted circle {
    fill: #0d47a1;
    stroke-width: 3px;
    filter: drop-shadow(0 0 10px rgba(30, 136, 229, 0.8));
  }

  /* Node Labels (visible on hover) */
  .node-label {
    font-size: 11px;
    font-weight: 600;
    fill: #37474f;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s ease;
    text-anchor: middle;
  }

  .graph-node:hover .node-label,
  .graph-node.highlighted .node-label {
    opacity: 1;
  }

  /* Tooltip */
  .tag-tooltip {
    position: absolute;
    padding: 10px 14px;
    background: rgba(255, 255, 255, 0.98);
    border-radius: 8px;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
    font-size: 13px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s ease;
    z-index: 100;
    max-width: 200px;
  }

  .tag-tooltip.visible {
    opacity: 1;
  }

  .tag-tooltip .tag-name {
    font-weight: 700;
    color: #1e88e5;
    margin-bottom: 4px;
  }

  .tag-tooltip .tag-count {
    color: #666;
    font-size: 12px;
  }

  /* Dark theme */
  html[data-theme="dark"] .tag-graph-container {
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  }

  html[data-theme="dark"] .graph-link {
    stroke: #64b5f6;
  }

  html[data-theme="dark"] .graph-node circle {
    fill: #64b5f6;
    stroke: #1a1a2e;
  }

  html[data-theme="dark"] .graph-node:hover circle {
    fill: #90caf9;
  }

  html[data-theme="dark"] .graph-node.highlighted circle {
    fill: #bbdefb;
  }

  html[data-theme="dark"] .graph-node.dimmed circle {
    fill: #455a64;
  }

  html[data-theme="dark"] .node-label {
    fill: #e0e0e0;
  }

  html[data-theme="dark"] .tag-tooltip {
    background: rgba(26, 26, 46, 0.98);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
  }

  html[data-theme="dark"] .tag-tooltip .tag-name {
    color: #64b5f6;
  }

  html[data-theme="dark"] .tag-tooltip .tag-count {
    color: #b0bec5;
  }

  /* Mobile adjustments */
  @media (max-width: 768px) {
    .tag-graph-container {
      margin: 20px 0 40px;
    }

    #tag-graph {
      height: 350px;
    }

    .node-label {
      font-size: 9px;
    }
  }
</style>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', function() {
    const svg = d3.select('#tag-graph');
    const tooltip = document.getElementById('tag-tooltip');
    const container = document.querySelector('.tag-graph-container');

    if (!svg.node() || !container) return;

    // Get post-tags data
    const postTagsData = JSON.parse(document.getElementById('post-tags-data').textContent);

    // Build nodes (unique tags) and edges (co-occurrences)
    const tagCounts = {};
    const edgeCounts = {};

    postTagsData.forEach(post => {
      const tags = post.tags || [];

      // Count tag occurrences
      tags.forEach(tag => {
        tagCounts[tag] = (tagCounts[tag] || 0) + 1;
      });

      // Count co-occurrences (edges)
      for (let i = 0; i < tags.length; i++) {
        for (let j = i + 1; j < tags.length; j++) {
          const key = [tags[i], tags[j]].sort().join('|||');
          edgeCounts[key] = (edgeCounts[key] || 0) + 1;
        }
      }
    });

    // Create nodes array
    const nodes = Object.entries(tagCounts).map(([tag, count]) => ({
      id: tag,
      count: count,
      radius: Math.max(6, Math.min(20, 4 + count * 3))
    }));

    // Create links array
    const links = Object.entries(edgeCounts).map(([key, count]) => {
      const [source, target] = key.split('|||');
      return {
        source,
        target,
        weight: count
      };
    });

    // Find max weight for normalization
    const maxWeight = Math.max(...links.map(l => l.weight), 1);

    // Setup SVG dimensions
    const width = container.offsetWidth;
    const height = parseInt(getComputedStyle(svg.node()).height);

    svg.attr('viewBox', [0, 0, width, height]);

    // Create force simulation
    const simulation = d3.forceSimulation(nodes)
      .force('link', d3.forceLink(links)
        .id(d => d.id)
        .distance(d => 80 - d.weight * 10)
        .strength(d => 0.3 + d.weight * 0.1))
      .force('charge', d3.forceManyBody()
        .strength(-120))
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('collision', d3.forceCollide()
        .radius(d => d.radius + 8)
        .strength(0.9))
      .force('x', d3.forceX(width / 2).strength(0.05))
      .force('y', d3.forceY(height / 2).strength(0.05));

    // Create links
    const link = svg.append('g')
      .attr('class', 'links')
      .selectAll('line')
      .data(links)
      .join('line')
      .attr('class', 'graph-link')
      .attr('stroke-width', d => Math.max(1, d.weight * 2));

    // Create nodes group
    const node = svg.append('g')
      .attr('class', 'nodes')
      .selectAll('g')
      .data(nodes)
      .join('g')
      .attr('class', 'graph-node')
      .call(d3.drag()
        .on('start', dragstarted)
        .on('drag', dragged)
        .on('end', dragended));

    // Add circles to nodes
    node.append('circle')
      .attr('r', d => d.radius);

    // Add labels (hidden by default, shown on hover)
    node.append('text')
      .attr('class', 'node-label')
      .attr('dy', d => -d.radius - 6)
      .text(d => d.id);

    // Node interactions
    node.on('mouseenter', function(event, d) {
      const nodeEl = d3.select(this);

      // Show tooltip
      tooltip.innerHTML = `
        <div class="tag-name">${d.id}</div>
        <div class="tag-count">${d.count} post${d.count > 1 ? 's' : ''}</div>
      `;
      tooltip.classList.add('visible');

      // Position tooltip
      const rect = container.getBoundingClientRect();
      const x = event.clientX - rect.left + 15;
      const y = event.clientY - rect.top - 10;
      tooltip.style.left = `${Math.min(x, width - 150)}px`;
      tooltip.style.top = `${y}px`;

      // Highlight connected nodes and links
      const connectedNodes = new Set();
      connectedNodes.add(d.id);

      link.each(function(l) {
        if (l.source.id === d.id || l.target.id === d.id) {
          connectedNodes.add(l.source.id);
          connectedNodes.add(l.target.id);
          d3.select(this).classed('highlighted', true).classed('dimmed', false);
        } else {
          d3.select(this).classed('dimmed', true).classed('highlighted', false);
        }
      });

      node.each(function(n) {
        if (connectedNodes.has(n.id)) {
          d3.select(this).classed('highlighted', true).classed('dimmed', false);
        } else {
          d3.select(this).classed('dimmed', true).classed('highlighted', false);
        }
      });
    })
    .on('mouseleave', function() {
      tooltip.classList.remove('visible');

      // Reset highlighting
      link.classed('highlighted', false).classed('dimmed', false);
      node.classed('highlighted', false).classed('dimmed', false);
    })
    .on('click', function(event, d) {
      event.preventDefault();
      const targetElement = document.getElementById(d.id);
      if (targetElement) {
        const offset = 100;
        const elementPosition = targetElement.getBoundingClientRect().top;
        const offsetPosition = elementPosition + window.pageYOffset - offset;
        window.scrollTo({
          top: offsetPosition,
          behavior: 'smooth'
        });
      }
    });

    // Update positions on tick
    simulation.on('tick', () => {
      // Keep nodes within bounds
      nodes.forEach(d => {
        d.x = Math.max(d.radius + 10, Math.min(width - d.radius - 10, d.x));
        d.y = Math.max(d.radius + 10, Math.min(height - d.radius - 10, d.y));
      });

      link
        .attr('x1', d => d.source.x)
        .attr('y1', d => d.source.y)
        .attr('x2', d => d.target.x)
        .attr('y2', d => d.target.y);

      node.attr('transform', d => `translate(${d.x},${d.y})`);
    });

    // Drag functions
    function dragstarted(event, d) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
    }

    function dragged(event, d) {
      d.fx = event.x;
      d.fy = event.y;
    }

    function dragended(event, d) {
      if (!event.active) simulation.alphaTarget(0);
      d.fx = null;
      d.fy = null;
    }

    // Handle resize
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        const newWidth = container.offsetWidth;
        const newHeight = parseInt(getComputedStyle(svg.node()).height);
        svg.attr('viewBox', [0, 0, newWidth, newHeight]);
        simulation.force('center', d3.forceCenter(newWidth / 2, newHeight / 2));
        simulation.force('x', d3.forceX(newWidth / 2).strength(0.05));
        simulation.force('y', d3.forceY(newHeight / 2).strength(0.05));
        simulation.alpha(0.3).restart();
      }, 300);
    });
  });
</script>
